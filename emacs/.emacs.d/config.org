* Emacs Configuration 2025 - Emacs v.31.

In August 2025 I updated my Emacs binary, pulling the latest source
code from the Git repository andy building it using the standard
instructions which are included in the Readme file.

Having created the new binary, and run 'make install' you can check
the version of the running Emacs by running 'M-x version'. The output
will provide the current Emacs version (31.0.50) along with some
information about the interface support.

In most cases the Emacs initialisation files (init.el and config.org)
can be used without any modification, but it is also a good
opportunity to revisit the existing files, reconsider their structure,
and whether there are any changes or improvements that can be made.

Here we are again, putting together a configuration file for this new
iteration.

** What The Configuration File Should Do.

Because Emacs is a tool which can do so many different jobs, it is
obvious that no two users are likely to have the same use case which
they need to address in their Emacs configuration. Someone who codes
for a living will be most interested in functions which enable dealing
with any code base that they interact with, and this may include
dealing with different languages, providing linting and code checking
in those languages and compilation and debugging support. An author of
prose is more likely to look for a setup which provides a way of
bashing out their text as quickly as possible, possibly supports
grammar and spelling checking and then allows text markup to turn the
document into a suitable format for sharing with others.

While the following outlines all the functions that will need to be
enabled, there is a section that introduces the whole thing, setting
up the connection to the package management system and enabling the
all important version control using Magit.

Some tools and settings are undoubtedly of interest across different
use cases. The ability to create automatically expanding text to speed
the process of writing, version control and electric[fn:1] behaviour
is universally useful and should be enabled for all use cases. The
sort of functionality that fits in this space are things like
automatic bracket and parenthesis pairing, colouring of bracket pairs
to help track and check that brackets are balanced and line wrapping
(in almost all cases).

The next breakdown into sections is the entirely aesthetic. They don't
really change the behaviour of the text being entered, but they do
affect the appearance. This would include colour themes, font choices
and the like.

Addressing the first of the major uses for Emacs, I'll start with text
entry. These are the functions that support writing documents of
various times. Examples of these functions will include Groff/Troff
support, HTML/CSS support (using Emmet) and LaTeX using AucTeX mode,
BibTeX and related products and then potentially various forms of
Markdown (which includes Org mode used to write this configuration
file).

The second major group will be the programming support. Ideally this
would provide programming support for all the languages that I'm
interested in writing and learning. This list would include Lisp (Slime),
Clojure, Python, C/C++ and probably Rust. Relevant extra functions
will include debuggers (gdb being the obvious example), code linters
etc.

* Configuration Tree.

The following should act as a framework for adding the various
functions as outlined above.

** Package Management Configuration.

Old enough, and ugly enough, I remember when the process of adding
packages into Emacs meant finding a relevant set of instructions for
each package, usually involving unpacking the code into a folder and
then compiling it and adding the configuration to your init file. More
recently, clearly taking inspiration from the package management
paradigm used in modern Linux distributions, Emacs now has the Melpa
package storage and the packages can be installed using the
'use-package' command. To enable this approach you start by
configuring the Melpa server as a repository. This is the equivalent
of having the distribution repository configured in sources.d or
similar, depending on your distribution.

The code below defines the repository location and type (melpa and
non-gnu).

#+begin_src emacs-lisp
  ;; Configure the Melpa package repositories that will be used in
  ;; the rest of the configuration file.
  (eval-and-compile)
  (require 'package)
  (add-to-list 'package-archives
  	     '("melpa" . "https://melpa.org/packages/"))
  (add-to-list 'package-archives
  	     '("nongnu" . "https://elpa.nongnu.org/nongnu/"))
  (package-initialize)
  (package-refresh-contents)
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t)
#+end_src

** Package Installation Development Cycle.

Some notes on the development process for this configuration file.

I have previously managed to generate a configuration file which does
pretty much everything that I want it to do, but I'm keen to improve
the structure of the file, especially with a view to making it easier
to maintain and build on in the future. A part of this is the defining
of the structure for the components that the file will
include. Testing of the file as it is developed is enabled by using
the GNU Stow package. Stow is described as a link farm management
package which allows you to create and modify the links to packages or
files in order to allow rapid switching from one version to another.

I tend to use GNU Stow to manage the text based configuration files
that I use throughout my Linux setup. I have a folder:

.dotfiles2025

in my home folder. Subfolders of this folder will hold the relevant
configuration files. To help manage the setup, this second level
folder is named to help identify the software being managed. In the
case of Emacs, the obvious name would be 'emacs' but if there are
different files required then the name could include a descriptor
(dev, final etc) or the version of the program being addressed.

The subfolders under this descriptor are then the folders structure
that is created relative to the target location for the configuration
file. In Emacs the configuration file is normally located in:

~/.emacs.d/

so the full path for the stowed configuration file is:

~/.dotfiles2025/emacs/.emacs.d/(config.org and init.el)

The process of 'installing' the configuration file using GNU Stow
should be relatively straightforward. Information can be found using
'man stow', but the following shows how to change the configuration
files from one version to another.

At this point, where I am using the previous configuration file
located in:

~/.dotfiles25/emacs2024/.emacs.d/config.org

the softlink in the folder:

~/.emacs.d/

points at the files (config.org and init.el) in the above folder.

To replace the files with this local 'in development' version run:

rm -rfv ~/.emacs.d

then, from the appropriate stow folder run:

stow emacs

This will create the symlink enabling the appropriate files.

The deletion step seems to be necessary as Stow won't overwrite an
existing link as a precautionary measure.

At this point in the development, I am using the previous version of
the configuration file, but will switch into the new version for
testing purposes as the file is expanded. Then, at some point, when
most of the useful functionality is in place I will switch to this
file full time.

** Magit Version Control.

When the question is raised, why use Emacs, one of the popular answers
is the Magit package. Magit is described as a porcelain (not sure
why!), but all I know is that it is a way of doing all the Git type
actions that you might want to do within the text editor itself. The
configuration below installs the Magit package and makes the key
mapping to access the Magit functions 'C-x g'. Magit is a menu driven
system for running through the normal cycle of Git functions, such as
adding files to staging, committing updates and pushing to the
repository. It also provides the more advanced functions such as
rebasing, but these are ofter accessed using M-x and then magit-
followed by the function you require.

I have long marvelled at how seamless the Magit functionality is
within Emacs, but I hadn't realised how good this was until, at work,
I had reason to try the popular 'Visual Studio' editor from
Microsoft. This editor, like most such systems nowadays, supports the
use of version control, but it is well clunky when compared to the
mighty Magit. Like most Windows stuff, it is mouse-centric, whereas
key driven approaches are so much more graceful.

#+begin_src emacs-lisp
  ;; Enable Magit and configure the 'Git status' key mapping.
  (use-package magit
    :config (global-set-key (kbd "C-x g") 'magit-status))
#+end_src

** Helm - Command Filtering Everywhere.

Emacs got its name from the fact that it is a large number of macros
which enable you to do all sorts of clever things. The command to go
to the beginning of a line is called with C-a, but the actual macro
you are running is org-beginning-of-line (this specific macro because
this file is being written in Org Mode). The most useful commands are,
like the above, mapped to a keymapping, and there are many keymaps
employed in a single Emacs setup. But there will still be many many
commands which you don't use enough to merit assigning a keystroke
to. Fortunately Emacs provides a straightforward way to run these
macros. The key pair 'M-x' will open the transitory window at the
bottom of the Emacs window and the command can be called by typing its
name. To a certain extent, this approach does require you to remember
the command you want to use, but Helm simplifies this by providing a
filtering process. Rather than typing the full name, in the right
order, and with the appropriate hyphens, type the words that you
expect to be in the macros command name and the displayed list of
macros will filter down until you are left with a handful of possible
candidates, or in many cases, just the command that you want.

When the filtering has reduced the number of options to a suitably
small number then the required macros can be selected, moving the
selection bar up or down using C-n (next) or C-p (previous) as
appropriate.

The Helm configuration below activates the Helm function and
configures a few popular Helm specific activities:

- Helm 'Find Files': M-<F5>
- Helm 'Buffers List': <F10>
- Helm 'Recent Files': S-<F10>

It is worth considering highlighting these keys in a Conky template at
some point, otherwise I will never use them! Checking just now, they
do all work as expected!

#+begin_src emacs-lisp
  ;; Activate helm, the filtering function.
  (use-package helm
    :bind (("M-x" . helm-M-x)
  	 ("M-<f5>" . helm-find-files)
  	 ([f10] . helm-buffers-list)
  	 ([S-f10] . helm-recentf))
    :config
    (helm-mode 1)
    (helm-autoresize-mode))
#+end_src

Practice makes perfect when it comes to using Helm. Use it and gain familiarity!

** Aesthetics Settings.

The next bunch of settings are not really necessary, but they do make
Emacs look prettier and easier on the eye.

*** Minimise the Screen Furniture in the Emacs Window.

Out of the box, Emacs has a menu bar, toolbar (complete with icons)
and the like. These are unnecessary because we'll be driving all the
usage through the keyboard.

#+begin_src emacs-lisp
  ;; Minimise the screen furniture.
  (menu-bar-mode 0)			; no menu bar
  (tool-bar-mode 0)			; no tool bar
  (blink-cursor-mode 0)			; steady cursor rather than blinking
  (scroll-bar-mode 0)			; no scroll bar... save the real estate
  (display-battery-mode 1)			; battery info in the mode line.
#+end_src

The line about displaying the time in the modeline has been removed
because I'll be using the Doom modeline which doesn't seem to support
time usage.

*** Don't Show the Splash Screen.

I usually start Emacs in the client mode so that it connects to a
daemon module (which is launched automatically if it isn't already
running). Because of this, I don't normally have a problem with the
splash screen being displayed. However, I don't want it displayed,
even if I run Emacs as a standalone instantiation. The following
switches off the splash screen.

#+begin_src emacs-lisp
  ;; Splash screen be gone!
  (setq inhibit-startup-message t)
#+end_src

*** Do Show a Pithy Quote Instead.

As the splash screen has been deactivated, the scratch buffer is
displayed by default. On its own it will contain some pretty dull text
about using the buffer. But who wants to settle for that.

The setting below is derived from a version I came up with when
working at the University. At that stage I had the same configuration
file in use at home and at work, so liked the idea of a different text
phrase being displayed in the different locations. This was achieved
by filtering on the system name and using this to select the
text. I'll leave it in place in case I start using the configuration
in multiple locations.

#+begin_src emacs-lisp
        ;; Display pithy text on the basis of system name
        (if (string=(system-name) "ziggyi5")
            (setq initial-scratch-message
    		"\n\n\n\n\t\t\tOnce upon a midnight dreary, while I pondered, weak and weary,
  \t\t\tOver many a quaint and curious volume of forgotten lore,
  \t\t\tWhile I nodded, nearly napping, suddenly there came a tapping,
  \t\t\tAs of some one gently rapping, rapping at my chamber door. “
  \t\t\t“'Tis some visitor,” I muttered, “tapping at my chamber door—
  \t\t\tOnly this, and nothing more.”"))
  (if (string=(system-name) "uk-rfieldse-l")
      (setq initial-scratch-message
  	    "Everything's science-fiction until someone makes it science fact.\n\nMarie Lu"))
#+end_src

*** Select A Dark Colour Theme.

I like to use a dark theme in Emacs (as I do in most of the programs
that I use), and there are a huge number available in Emacs. My
preference is for one with a relatively dark background, but with
fairly colourful font colourisation for the text as this helps in
reading the structure of things like code and markup.

There is a useful gallery website which shows examples of the various
themes available. This can be found here:

https://emacsthemes.com/

I'm going to go with 'Catppuccin' for the time being. There is a
development repository for the theme here:

https://github.com/catppuccin/emacs

But it is also in the Melpa repositories, so can be installed using
the same use-package commands.

#+begin_src emacs-lisp
        ;; Catppuccin Machiato theme
        (use-package catppuccin-theme
          :ensure t
          :config (setq catppuccin-flavor 'macchiato)
  	(catppuccin-reload))
#+end_src

I do like the new theme, especially the colours of the markup language entries.

*** Set A Nice Font.

A popular subject on the Emacs Porn sub-reddit is the font that people
like to use with Emacs. I've regularly settled on some version of
Hack, so I'm going to stick with that.

#+begin_src emacs-lisp
  ;; Set the font to Hack, and experiment a little with the size.
  (add-to-list 'default-frame-alist '(font . "Hack-7"))
  (set-face-attribute 'default nil
  		    :family "Hack")
#+end_src

Setting the font to size 7 might be a step too far, but I'll use it
for a little while, see how I get on.

*** Modify Frame Title to Useful Text.

The standard text in the frame heading has the form:

filename - GNU Emacs at ziggyi5

While this does give you the bare information, it could be more
useful.

#+begin_src emacs-lisp
  ;; Modify frame title from:
  ;; filename - GNU Emacs at system name
  ;; to
  ;; Emacs - Buffer: > File
  (setq frame-title-format '("Emacs - Buffer: %b > File: %f"))
#+end_src

This approach displays the buffer name and the file (including path)
in the frame title bar.

*** Highlighting the Current Line.

Sometimes it can be difficult to locate the line that you are working
on. This setting switches on highlighting for the line that the cursor
is currently on, to make it easier to find where you are.

This is one of the first settings that feels like it could be added
either as a purelf aesthetic entry or as a 'behaviour that is useful
in all modes'. Currently I'm going to treat it as an aesthetic
setting, but it could live in the alternate location just as readily.

#+begin_src emacs-lisp
  ;; Turn on highlighiing of the current line.
  (global-hl-line-mode 1)
#+end_src

*** Replace Standard Modeline with Doom Emacs Version.

The Modeline is the information line just above the bottom of the
active Emacs window. The standard version is fine, informative, but
the Doom Emacs version uses the Nerd Font to highlight the file type.

#+begin_src emacs-lisp
  ;; Activate the Doom Mode Line.
  (use-package doom-modeline
    :ensure t
    :init (doom-modeline-mode 1))
#+end_src

If the icon on the Doom Modeline shows a Unicode character then the
required font isn't installed. Google for instructions on installing
the Doom Modeline fonts for instructions.

** Behaviours That Are Useful In All The Modes.

*** Parenthesis Pairing - add the closing bracket automatically.

*** Rainbow Colouring Of Brackets - Useful to check bracket pairing


*** Spell Checking - Check Spelling Against UK British Dictionary.

** Writing Prose And Documents.

*** Groff/Troff Editing

*** HTML/CSS Editing Using Emmet

*** LaTeX Using AucTeX/BibTeX/RefTeX.

*** Manage the Bibliographic Databases Using eBib.

*** Markdown and Org Mode Document Preparation.

** Programming Modes and Support.

*** Makefile.

*** Lisp/Clojure.

*** Python.

*** C/C++.

*** Rust.

*** Debugging.

* Footnotes

[fn:1] In Emacs, the term 'electric' behaviour refers to extra
behaviour triggered when various keys are pressed. The term is most
often used to describe the enter or return key moving the cursor to
the next line (the usual behaviour) and also carry out the action that
adding the tab key would provide. In writing code the electric
behaviour will indent the next line, especially useful when writing an
indent sensitive language such as Python.
