* Emacs Configuration 2025 - Emacs v.31.

In August 2025 I updated my Emacs binary, pulling the latest source
code from the Git repository andy building it using the standard
instructions which are included in the Readme file.

Having created the new binary, and run 'make install' you can check
the version of the running Emacs by running 'M-x version'. The output
will provide the current Emacs version (31.0.50) along with some
information about the interface support.

In most cases the Emacs initialisation files (init.el and config.org)
can be used without any modification, but it is also a good
opportunity to revisit the existing files, reconsider their structure,
and whether there are any changes or improvements that can be made.

Here we are again, putting together a configuration file for this new
iteration.

** What The Configuration File Should Do.

Because Emacs is a tool which can do so many different jobs, it is
obvious that no two users are likely to have the same use case which
they need to address in their Emacs configuration. Someone who codes
for a living will be most interested in functions which enable dealing
with any code base that they interact with, and this may include
dealing with different languages, providing linting and code checking
in those languages and compilation and debugging support. An author of
prose is more likely to look for a setup which provides a way of
bashing out their text as quickly as possible, possibly supports
grammar and spelling checking and then allows text markup to turn the
document into a suitable format for sharing with others.

While the following outlines all the functions that will need to be
enabled, there is a section that introduces the whole thing, setting
up the connection to the package management system and enabling the
all important version control using Magit.

Some tools and settings are undoubtedly of interest across different
use cases. The ability to create automatically expanding text to speed
the process of writing, version control and electric[fn:1] behaviour
is universally useful and should be enabled for all use cases. The
sort of functionality that fits in this space are things like
automatic bracket and parenthesis pairing, colouring of bracket pairs
to help track and check that brackets are balanced and line wrapping
(in almost all cases).

The next breakdown into sections is the entirely aesthetic. They don't
really change the behaviour of the text being entered, but they do
affect the appearance. This would include colour themes, font choices
and the like.

Addressing the first of the major uses for Emacs, I'll start with text
entry. These are the functions that support writing documents of
various times. Examples of these functions will include Groff/Troff
support, HTML/CSS support (using Emmet) and LaTeX using AucTeX mode,
BibTeX and related products and then potentially various forms of
Markdown (which includes Org mode used to write this configuration
file).

The second major group will be the programming support. Ideally this
would provide programming support for all the languages that I'm
interested in writing and learning. This list would include Lisp (Slime),
Clojure, Python, C/C++ and probably Rust. Relevant extra functions
will include debuggers (gdb being the obvious example), code linters
etc.

* Configuration Tree.

The following should act as a framework for adding the various
functions as outlined above.

** Package Management Configuration.

Old enough, and ugly enough, I remember when the process of adding
packages into Emacs meant finding a relevant set of instructions for
each package, usually involving unpacking the code into a folder and
then compiling it and adding the configuration to your init file. More
recently, clearly taking inspiration from the package management
paradigm used in modern Linux distributions, Emacs now has the Melpa
package storage and the packages can be installed using the
'use-package' command. To enable this approach you start by
configuring the Melpa server as a repository. This is the equivalent
of having the distribution repository configured in sources.d or
similar, depending on your distribution.

The code below defines the repository location and type (melpa and
non-gnu).

#+begin_src emacs-lisp
  ;; Configure the Melpa package repositories that will be used in
  ;; the rest of the configuration file.
  (eval-and-compile)
  (require 'package)
  (add-to-list 'package-archives
  	     '("melpa" . "https://melpa.org/packages/"))
  (add-to-list 'package-archives
  	     '("nongnu" . "https://elpa.nongnu.org/nongnu/"))
  (package-initialize)
  (package-refresh-contents)
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t)
#+end_src

** Package Installation Development Cycle.

Some notes on the development process for this configuration file.

I have previously managed to generate a configuration file which does
pretty much everything that I want it to do, but I'm keen to improve
the structure of the file, especially with a view to making it easier
to maintain and build on in the future. A part of this is the defining
of the structure for the components that the file will
include. Testing of the file as it is developed is enabled by using
the GNU Stow package. Stow is described as a link farm management
package which allows you to create and modify the links to packages or
files in order to allow rapid switching from one version to another.

I tend to use GNU Stow to manage the text based configuration files
that I use throughout my Linux setup. I have a folder:

.dotfiles2025

in my home folder. Subfolders of this folder will hold the relevant
configuration files. To help manage the setup, this second level
folder is named to help identify the software being managed. In the
case of Emacs, the obvious name would be 'emacs' but if there are
different files required then the name could include a descriptor
(dev, final etc) or the version of the program being addressed.

The subfolders under this descriptor are then the folders structure
that is created relative to the target location for the configuration
file. In Emacs the configuration file is normally located in:

~/.emacs.d/

so the full path for the stowed configuration file is:

~/.dotfiles2025/emacs/.emacs.d/(config.org and init.el)

The process of 'installing' the configuration file using GNU Stow
should be relatively straightforward. Information can be found using
'man stow', but the following shows how to change the configuration
files from one version to another.

At this point, where I am using the previous configuration file
located in:

~/.dotfiles25/emacs2024/.emacs.d/config.org

the softlink in the folder:

~/.emacs.d/

points at the files (config.org and init.el) in the above folder.

To replace the files with this local 'in development' version run:

rm -rfv ~/.emacs.d

then, from the appropriate stow folder run:

stow emacs

This will create the symlink enabling the appropriate files.

The deletion step seems to be necessary as Stow won't overwrite an
existing link as a precautionary measure.

At this point in the development, I am using the previous version of
the configuration file, but will switch into the new version for
testing purposes as the file is expanded. Then, at some point, when
most of the useful functionality is in place I will switch to this
file full time.

** Magit Version Control.

When the question is raised, why use Emacs, one of the popular answers
is the Magit package. Magit is described as a porcelain (not sure
why!), but all I know is that it is a way of doing all the Git type
actions that you might want to do within the text editor itself. The
configuration below installs the Magit package and makes the key
mapping to access the Magit functions 'C-x g'. Magit is a menu driven
system for running through the normal cycle of Git functions, such as
adding files to staging, committing updates and pushing to the
repository. It also provides the more advanced functions such as
rebasing, but these are ofter accessed using M-x and then magit-
followed by the function you require.

I have long marvelled at how seamless the Magit functionality is
within Emacs, but I hadn't realised how good this was until, at work,
I had reason to try the popular 'Visual Studio' editor from
Microsoft. This editor, like most such systems nowadays, supports the
use of version control, but it is well clunky when compared to the
mighty Magit. Like most Windows stuff, it is mouse-centric, whereas
key driven approaches are so much more graceful.

#+begin_src emacs-lisp
  ;; Enable Magit and configure the 'Git status' key mapping.
  (use-package magit
    :config (global-set-key (kbd "C-x g") 'magit-status))
#+end_src

** Helm - Command Filtering Everywhere.

Emacs got its name from the fact that it is a large number of macros
which enable you to do all sorts of clever things. The command to go
to the beginning of a line is called with C-a, but the actual macro
you are running is org-beginning-of-line (this specific macro because
this file is being written in Org Mode). The most useful commands are,
like the above, mapped to a keymapping, and there are many keymaps
employed in a single Emacs setup. But there will still be many many
commands which you don't use enough to merit assigning a keystroke
to. Fortunately Emacs provides a straightforward way to run these
macros. The key pair 'M-x' will open the transitory window at the
bottom of the Emacs window and the command can be called by typing its
name. To a certain extent, this approach does require you to remember
the command you want to use, but Helm simplifies this by providing a
filtering process. Rather than typing the full name, in the right
order, and with the appropriate hyphens, type the words that you
expect to be in the macros command name and the displayed list of
macros will filter down until you are left with a handful of possible
candidates, or in many cases, just the command that you want.

When the filtering has reduced the number of options to a suitably
small number then the required macros can be selected, moving the
selection bar up or down using C-n (next) or C-p (previous) as
appropriate.

The Helm configuration below activates the Helm function and
configures a few popular Helm specific activities:

- Helm 'Find Files': M-<F5>
- Helm 'Buffers List': <F10>
- Helm 'Recent Files': S-<F10>

It is worth considering highlighting these keys in a Conky template at
some point, otherwise I will never use them! Checking just now, they
do all work as expected!

#+begin_src emacs-lisp
  ;; Activate helm, the filtering function.
  (use-package helm
    :bind (("M-x" . helm-M-x)
  	 ("M-<f5>" . helm-find-files)
  	 ([f10] . helm-buffers-list)
  	 ([S-f10] . helm-recentf))
    :config
    (helm-mode 1)
    (helm-autoresize-mode))
#+end_src

Practice makes perfect when it comes to using Helm. Use it and gain familiarity!

** Aesthetics Settings.

The next bunch of settings are not really necessary, but they do make
Emacs look prettier and easier on the eye.

*** Minimise the Screen Furniture in the Emacs Window.

Out of the box, Emacs has a menu bar, toolbar (complete with icons)
and the like. These are unnecessary because we'll be driving all the
usage through the keyboard.

#+begin_src emacs-lisp
  ;; Minimise the screen furniture.
  (menu-bar-mode 0)			; no menu bar
  (tool-bar-mode 0)			; no tool bar
  (blink-cursor-mode 0)			; steady cursor rather than blinking
  (scroll-bar-mode 0)			; no scroll bar... save the real estate
  (display-battery-mode 1)			; battery info in the mode line.
#+end_src

The line about displaying the time in the modeline has been removed
because I'll be using the Doom modeline which doesn't seem to support
time usage.

*** Don't Show the Splash Screen.

I usually start Emacs in the client mode so that it connects to a
daemon module (which is launched automatically if it isn't already
running). Because of this, I don't normally have a problem with the
splash screen being displayed. However, I don't want it displayed,
even if I run Emacs as a standalone instantiation. The following
switches off the splash screen.

#+begin_src emacs-lisp
  ;; Splash screen be gone!
  (setq inhibit-startup-message t)
#+end_src

*** Do Show a Pithy Quote Instead.

As the splash screen has been deactivated, the scratch buffer is
displayed by default. On its own it will contain some pretty dull text
about using the buffer. But who wants to settle for that.

The setting below is derived from a version I came up with when
working at the University. At that stage I had the same configuration
file in use at home and at work, so liked the idea of a different text
phrase being displayed in the different locations. This was achieved
by filtering on the system name and using this to select the
text. I'll leave it in place in case I start using the configuration
in multiple locations.

#+begin_src emacs-lisp
        ;; Display pithy text on the basis of system name
        (if (string=(system-name) "ziggyi5")
            (setq initial-scratch-message
    		"\n\n\n\n\t\t\tOnce upon a midnight dreary, while I pondered, weak and weary,
  \t\t\tOver many a quaint and curious volume of forgotten lore,
  \t\t\tWhile I nodded, nearly napping, suddenly there came a tapping,
  \t\t\tAs of some one gently rapping, rapping at my chamber door. “
  \t\t\t“'Tis some visitor,” I muttered, “tapping at my chamber door—
  \t\t\tOnly this, and nothing more.”"))
  (if (string=(system-name) "uk-rfieldse-l")
      (setq initial-scratch-message
  	    "Everything's science-fiction until someone makes it science fact.\n\nMarie Lu"))
#+end_src

*** Select A Dark Colour Theme.

I like to use a dark theme in Emacs (as I do in most of the programs
that I use), and there are a huge number available in Emacs. My
preference is for one with a relatively dark background, but with
fairly colourful font colourisation for the text as this helps in
reading the structure of things like code and markup.

There is a useful gallery website which shows examples of the various
themes available. This can be found here:

https://emacsthemes.com/

I'm going to go with 'Catppuccin' for the time being. There is a
development repository for the theme here:

https://github.com/catppuccin/emacs

But it is also in the Melpa repositories, so can be installed using
the same use-package commands.

#+begin_src emacs-lisp
        ;; Catppuccin Machiato theme
        (use-package catppuccin-theme
          :ensure t
          :config (setq catppuccin-flavor 'macchiato)
  	(catppuccin-reload))
#+end_src

I do like the new theme, especially the colours of the markup language entries.

*** Set A Nice Font.

A popular subject on the Emacs Porn sub-reddit is the font that people
like to use with Emacs. I've regularly settled on some version of
Hack, so I'm going to stick with that.

#+begin_src emacs-lisp
  ;; Set the font to Hack, and experiment a little with the size.
  (add-to-list 'default-frame-alist '(font . "Hack-11"))
  (set-face-attribute 'default nil
  		    :family "Hack")
#+end_src

Setting the font to size 7 might be a step too far, but I'll use it
for a little while, see how I get on.

*** Modify Frame Title to Useful Text.

The standard text in the frame heading has the form:

filename - GNU Emacs at ziggyi5

While this does give you the bare information, it could be more
useful.

#+begin_src emacs-lisp
  ;; Modify frame title from:
  ;; filename - GNU Emacs at system name
  ;; to
  ;; Emacs - Buffer: > File
  (setq frame-title-format '("Emacs - Buffer: %b > File: %f"))
#+end_src

This approach displays the buffer name and the file (including path)
in the frame title bar.

*** Highlighting the Current Line.

Sometimes it can be difficult to locate the line that you are working
on. This setting switches on highlighting for the line that the cursor
is currently on, to make it easier to find where you are.

This is one of the first settings that feels like it could be added
either as a purelf aesthetic entry or as a 'behaviour that is useful
in all modes'. Currently I'm going to treat it as an aesthetic
setting, but it could live in the alternate location just as readily.

#+begin_src emacs-lisp
  ;; Turn on highlighiing of the current line.
  (global-hl-line-mode 1)
#+end_src

*** Replace Standard Modeline with Doom Emacs Version.

The Modeline is the information line just above the bottom of the
active Emacs window. The standard version is fine, informative, but
the Doom Emacs version uses the Nerd Font to highlight the file type.

#+begin_src emacs-lisp
  ;; Activate the Doom Mode Line.
  (use-package doom-modeline
    :ensure t
    :init (doom-modeline-mode 1))
#+end_src

If the icon on the Doom Modeline shows a Unicode character then the
required font isn't installed. Google for instructions on installing
the Doom Modeline fonts for instructions.

*** Emacs Window Transparency Settings.

Transparency in Emacs relies on a functioning Compositor. The i3wm
doesn't use the same compositor as Gnome or KDE, so it needs to be
installed and configured separately. Once it is running it can be
configured to different levels of transparency.

#+begin_src emacs-lisp
  ;; Transparency - super groovy!
  (set-frame-parameter (selected-frame) 'alpha '(80 50))
  (add-to-list 'default-frame-alist '(alpha 80 50))
#+end_src

The 80/50 configure the transparency for the active and inactive modes.

*** Fancy Bullets When Using Org Mode.

This file is one example of an Org Mode file. Org Mode is a
specialised markup language created for use within Emacs. It can be
used as a quick way to write files which can then be processed into
LaTeX or HTML files. Like other markup languages, Org Mode uses simple
tags that can then be processed into an appropriate structure. It uses
asterisks at the beginning of lines for heading levels, so a single *
would become the equivalent of a LaTeX \\section or HTML h1. Extra
asterisks give h2, h3 etc.

When writing the file in Org Mode, the asterisks can be replaced by
prettier icons using Org Bullets as below.

#+begin_src emacs-lisp
  ;; Pretty Bullets for Org Mode Markdown.
  (use-package org-bullets
    :config (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+end_src
** Emacs As A File Manager.
*** Using Emacs Dired Mode For File Management.

I wouldn't recommend using Emacs as a file manager. That isn't really
what it is for, and while it can do some of the functions of a file
manager (and it can do some things that most file managers can't do!)
it does provide a bare bones set of behaviours that can help you work
with multiple files while still staying in the Emacs environment and
using the keys and functions provided by it.

The primary method of working with files within Emacs is the Dired
function. Type 'C-x C-f' and enter a path to a folder rather than to a
specific file and you'll be shown the contents of the folder, and
you'll be in the Dired mode.

*** Deleting and Creating Files Using Dired.

Out of the box, Dired provides the ability to delete files. Move the
cursor to the line for the file you want to delete and hit d, repeat
for each file that you want to delete, and when all the selections are
made hit x for execute and the files will be deleted.

Creating files is straightforward. Use C-x C-f for find-file. The
filename is entered in the modeline.

*** Text Search and Replace From The Dired Buffer.

So far, so good, but more impressive are things like the ability to do
text search and replace for the files from the Dired view. Information
on how to do this is on this page:

https://www.emacswiki.org/emacs/DiredSearchAndReplace

At a bare minimum, a simple search and replace across any number of
files is useful, but throw in the ability to select which files are
processed using grep or regular expressions and you have a powerhouse
of rapid file modifications directly from what appears to be a simple
file manager!

*** Recent Files Function.

There are times when you will need to keep going back to a small
number of files. Like many other programs, Emacs supports this. Again,
there is a file for storing the relevant information, and as with
other files this is stored in the .backups folder.

#+begin_src emacs-lisp
  ;; Configure recent file functionality
  (use-package recentf
    :config
    (setq recentf-save-file "~/.backups/.recentf")
    recentf-max-saved-items 100
    recentf-max-menu-items 100
    (recentf-mode +1)
    (global-set-key (kbd "C-x C-r") 'recentf-open-files))
#+end_src

When the list of recent files is displayed using C-x C-r, then the
most recent entries are also tagged with the numbers 1-0, and the
relevant file can be opened by hitting the appropriate number for
those entries. Other entries can be selected by moving the cursor up
or down to the required line, by searching using C-s (forward search)
or C-r (backward search).

*** Display Useful Git Related Information in Dired.

When configuring the early stages of this file, one of the first
settings to add was the section that added Magit, the Emacs
implementation of git version control. When you start using git
outside of Magit, especially on other platforms, you quickly realise
just how good Magit is.

Dired can show git related information within the Dired buffer.

#+begin_src emacs-lisp
  ;; Enable git information display in the Dired mode.
  (use-package dired-git-info)
  (with-eval-after-load 'dired
    (define-key dired-mode-map ")" 'dired-git-info-mode))
#+end_src

When in a Dired buffer which is under git management, hit the ) key to
show the git information.
** Behaviours That Are Useful In All The Modes.
*** Parenthesis Pairing - add the closing bracket automatically.

Parenthesis pairing is provided by the use of 'electric
behaviour'. Once this is set up then adding the opening bracket will
trigger adding the closing bracket and will place the cursor between
the two brackets.

The brackets in this case includes:

parenthesis - ()
square brackets - []
curly brackets - {}
speech marks - ""
single quotes - ''

When writing Lisp the pairing of single quotes can be a pain, but I
don't do enough Lisp to make me want to fix this. This may change in
the future.

#+begin_src emacs-lisp
  ;; Electric Brackets
  (use-package electric
    :ensure t
    :init
    :config (add-hook 'prog-mode-hook 'electric-pair-mode)
    :config (add-hook 'LaTeX-mode-hook 'electric-pair-mode)
    :config (add-hook 'latex-mode-hook 'electric-pair-mode)
    :config (add-hook 'text-mode-hook 'electric-pair-mode)
    :config (add-hook 'org-mode-hook 'electric-pair-mode)
    :config (add-hook 'pov-mode-hook 'electric-pair-mode))
#+end_src

*** Rainbow Colouring Of Brackets - Useful to check bracket pairing

Emacs provides an excellent method of managing brackets by using
electric brackets (see 'Parenthesis Pairing'), but this function also
helps you track the brackets by colouring the opening and closing
brackets the same colour.

#+begin_src emacs-lisp
  ;; Rainbow Delimiters (this needs setting for relevant modes).
  (use-package rainbow-delimiters
    :ensure t
    :init
    :config (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
    :config (add-hook 'LaTeX-mode-hook 'rainbow-delimiters-mode)
    :config (add-hook 'latex-mode-hook 'rainbow-delimiters-mode)
    :config (add-hook 'text-mode-hook 'rainbow-delimiters-mode)
    :config (add-hook 'org-mode-hook 'rainbow-delimiters-mode)
    :config (add-hook 'pov-mode-hook 'rainbow-delimiters-mode))
#+end_src

*** Bracket/Parenthesis Pair Highlighting Function.

The rainbow colouring of brackets and adding brackets as pairs both
provide excellent, reliable methods to ensure brackets are
balanced. The following setting provides another method, highlighting
the other half of each pair when the cursor is in place.

#+begin_src emacs-lisp
  ;; Highlight the other half of a matching pair when the cursor is
  ;; on a bracket or similar.
  (show-paren-mode 1)
#+end_src

*** Spell Checking - Check Spelling Against UK British Dictionary.

#+begin_src emacs-lisp
    ;; spellchecking
    (setq ispell-program-name "/usr/bin/aspell")
    (setq ispell-dictionary "british"
          ispell-extra-args '() ;; TeX mode "-t"
    	ispell-silently-savep t)

    ;; Configure a personal dictionary
    (setq ispell-personal-dictionary "~/.backups/ispell-personal-dictionary")
    ;; flyspell
    (use-package flyspell
      :ensure t
      :init
      :config (add-hook 'text-mode-hook 'flyspell-mode)
      :config (add-hook 'prog-mode-hook 'flyspell-mode)
      :config (add-hook 'LaTeX-mode-hook 'flyspell-mode)
      :config (add-hook 'latex-mode-hook 'flyspell-mode)
      :config (add-hook 'org-mode-hook 'flyspell-mode)
      :config (define-key flyspell-mode-map (kbd "C-,") 'helm-flyspell-correct))
#+end_src

*** Grammar Checking - Flycheck For Other Types of Language Checking.

#+begin_src emacs-lisp
  ;; install and configure flycheck
  (use-package flycheck
    :ensure t
    :init (global-flycheck-mode))
#+end_src

*** Global Line Numbering.

Back when I first started playing around with computers, back when ZX
Spectrums were cutting edge and BASIC was the programming language of
choice, writing programs involved putting a number at the beginning of
every line, usually incremented in 10s in order to leave space for
extra lines if required.

Most other languages don't require the numbering of lines, but it can
still be useful to get an idea of how many lines your file has, and it
can ever provide a way of navigating the file quickly. To support
this, I'm now going to switch on the displaying of the line number at
the left hand edge of the Emacs frame.

#+begin_src emacs-lisp
  ;; Activate line numbering
  (global-display-line-numbers-mode t)
#+end_src

The number can be used to navigate around using:

M-g g or M-g M-g and then type the line number to move to.

Of course, moving to the beginning or end of the file you can use M-<
and M->. Otherwise search for text as a quick way of getting around.

One point of note is the line numbering when using folding. Folding is
a great way of being able to focus on a specific part of the text. If
working appropriately, using Tab can cycle the visibility of a section
of the file by folding (hiding) the section of text. The global
numbering counts these lines even though they aren't visible. This
means that this file leaps from 73-107, from 107-178 etc. Entering a
line number which is hidden will cause the section to be opened.

*** Line Wrapping Everywhere and Every Mode.

By default, Emacs doesn't have line-wrapping switched on by
default. The following is the configuration to activate the line wrap.

#+begin_src emacs-lisp
  ;; Activate auto-fill mode as a minor mode for all the popular modes
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'LaTeX-mode-hook 'turn-on-auto-fill)
  (add-hook 'latex-mode-hook 'turn-on-auto-fill)
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
  (add-hook 'emacs-lisp-mode-hook 'turn-on-auto-fill)
  (add-hook 'fundamental-mode-hook 'turn-on-auto-fill)
  (add-hook 'prog-mode-hook 'turn-on-auto-fill)
#+end_src

Using 'prog-mode-hook' activates the wrapping for all manner of
programming modes.

*** Backup File Management.

The default backup behaviour for Emacs is to create a copy of the file
that is being backed up but with attached number tags ~<no.>~ stored
in the same directory as the original. This can lead to a number of
random files filling these folders up.

The reconfigured version saves these backups into a shared folder, in
my case ~/.backups/

#+begin_src emacs-lisp
  ;; set backup target directory and behaviour
  (setq backup-directory-alist
        '(("." . "~/.backups/")))
  (setq backup-by-copying t
        delete-old-versions t
        kept-new-versions 2
        kept-old-versions 2
        version-control t)
#+end_src

*** Return To The Previous Location In The File.

When working on a project, it is likely you'll need to keep on
returning to a small subset of files and, in many cases to the same
locations. The following configures this and saves the information
into a file in the backup folder.

#+begin_src emacs-lisp
  ;; SavePlace behaviour - back to your last location
  (save-place-mode 1)
  (setq save-place-file "~/.backups/.places")
#+end_src

*** Emacs Command History Persistence Using savehist.

When working on the command line, one of the really useful functions
is to be able to recall previous commands that have been entered in
Bash. This can be done using either the command 'history' or using C-r
to search backwards through the command list.

A similar function for Emacs is provided by using a history file,
configured below.

#+begin_src emacs-lisp
  ;; Persistent command history between Emacs sessions.
  (setq savehist-file "~/.backups/emacs-history"
        history-length t
        history-delete-duplicates t
        savehist-save-minibuffers-history 1
        savehist-additional-variables
        '(kill-ring
  	search-ring
  	regexp-search-ring))
  (savehist-mode 1)
#+end_src

*** White Space Trimming.

It is often the case that, when working repeatedly on a single file
then that file can end up having extra white space added or left over
at the end of the file. This can happen because of text deleted
during the editing phase, or just from random extra lines being added
when the text is being written. The following function removes
excessive text from the end of a document. It is also useful when the
files are under version control because extra lines at the end of a
document may trigger the document being considered a new version.

This approach also removes extra characters at the end of the lines in
the document. There is discussion on providing this functionality in
the Emacs Wiki page on white space removal.

#+begin_src emacs-lisp
  ;; Remove blank lines from the end of the file.
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

The function is one of the first in the file to be added to the list
of functions activated when a particular event is taking place. In
this case the 'delete-trailing-whitespace function is executed when
the file is saved.

A useful note for functions of this type is how you can find
information on what they do. M-x describe function and then enter the
function name, and you'll see a guide on what the function actually
does, along with any modifications available in the command.

*** Simplified Response for Yes/No Questions.

The default behaviour for Emacs when requiring yes/no answers is for
the answer to be the full word in each case. The following function
simplifies this to y/n.

#+begin_src emacs-lisp
  ;; Use y/n rather than yes/no
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

*** Make the Default Emacs Mode 'Text' Mode.

Configure the default mode in Emacs to be text mode.

#+begin_src emacs-lisp
  ;; Set the default major mode to text mode.
  (setq-default major-mode 'text-mode)
#+end_src
*** Dynamic Text Expansion.

A simple way of expanding text that has been entered previously. This
doesn't require any configuring, so this is just a note on using the
text expansion.

If you have written a word or phrase and you want to repeat it, then
you can start the phrase and then use the key 'M-/'.

For example, a piece of laboratory equipment is called a Weissenberg
Rheogoniometer. This is a heck of a thing to have to type on the
regular. So, instead, type Wei and then use the M-/ to expand it:

Weissenberg Rheogoniometer

Hitting M-/ twice will replay both words.

*** Automatic Text Expansion Of Configured Phrases.

There was a time when I first started doing text processing where I
wanted to discover a method of expanding text to save me typing.

The expansions are saved to the file defined in this configuration.

#+begin_src emacs-lisp
  ;; Automatic expansion of configured abbreviations.
  (setq-default abbrev-mode t)
  (setq abbrev-file-name "~/.backups/.abbrev_defs")
  (setq save-abbrevs 'silently)
#+end_src

bw -> Best wishes
hth -> Hope that helps
li -> Lizzie
lif -> Lizzie Fieldsend
mo -> Morag
mof -> Morag Fieldsend
mw -> MathWorks
ri -> Richard
rif -> Richard Fieldsend
teh -> the
wr -> Weissenberg Rheogoniometer

Extra abbreviations can be added by typing the text that you want
expanded and then type either of these commands:

C-x a i g - Global abbreviations working in every mode

C-x a i l - Local abbreviations working in the current mode

The updates will be saved to the abbreviations file when Emacs is
closed using C-x C-c.
*** Bookmarking in Emacs.

Bookmarking is pretty much exactly what you would imagine it to be, a
way of marking locations in any number of files. The bookmark storage
file is located in the .backups file where many of the other storage
files are kept.

#+begin_src emacs-lisp
  ;; Configure where the bookmarks will be stored.
  (set 'bookmark-default-file "~/.backups/.bookmarks")
#+end_src

The process of using bookmarks includes the following activities:

C-x r m - Mark the location where the cursor is using a bookmark. The
bookmark can be titled to help identify the bookmark later.

C-x r b - Jump to a bookmark

C-x r l - List the available bookmarks.

The bookmark list can be navigated and edited in the bookmarks
list. Mark a bookmark for deletion by selecting a bookmark and hitting
d. Deletion actually takes place when 'executed' by hitting x. This is
similar behaviour to the Dired file management function.

Further information on using the Bookmark function can be found on
this wiki page:

https://www.emacswiki.org/emacs/BookMarks

*** Low Distraction Environments for Writing.

While I continue to harbour fantasies of writing, I sometimes look at
tools that are available, and that exist primarily to make such a
dream more feasible.

This section covers the availability and type of tools. Within Emacs
these tools are three different text editing modes which minimise the
distractions that appear on the screen. The theory being that writing
should be about concentrating on the text that you are working on, and
not the wider ecosystem that this exists in. The use of Emacs as a
text editor rather than using a word processor is somewhat an example
of how this works. Concentrate on the words themselves, not on how
they will eventually look.

After the discussion of the modes available and a summary of their
display approach, there is a commentary on the non-laptop based
approaches to this issue.

**** Low Distraction Mode 1 - Write Room Mode.

#+begin_src emacs-lisp
  ;; Write Room Mode.
  (use-package writeroom-mode)
#+end_src

Once the above configuration is in place, then Write Room Mode is
activated using M-x writeroom-mode. This activates the mode, which
then expands the Emacs screen to full screen mode without any border
or menu visible. The text is centred on the screen by adding two broad
borders on the left and right hand side. The actual text itself is of
the standard font and size configured elsewhere in the configuration
file.

Deactivating the mode by using M-x writeroom-mode again returns the
screen to its previous layout.

**** Low Distraction Mode 2 - Olivetti Mode.

#+begin_src emacs-lisp
  ;; Olivetti Mode.
  (use-package olivetti)
  (require 'olivetti)
#+end_src

Olivetti Mode is similar to the Writeroom Mode, as you would expect,
given that it is intended to provide similar functionality. The
differences are that it doesn't make the Emacs window full screen, and
leaves the titlebar and taskbar at the top and bottom of the screen
respectively both visible. On my i3wm setup, moving the Emacs window
to its own desktop gives a similar setup to Writeroom, though the
borders are such that the central text is narrower, giving an odd word
wrapping.

The text column can be broadened using C-c}, or narrowed using
C-c{. The text width can be set using C-c\ and enter he text with as a
number.

**** Low Distraction Mode 3 - Dark Room Mode.

#+begin_src emacs-lisp
  ;; Dark room mode
  (use-package darkroom)
#+end_src

Darkroom mode is similar to Olivetti Mode in that it keeps the
titlebar and taskbar in place, but the text size is increased
somewhat. Nice and restful on the eyes, but not as minimal as
Writeroom.

My initial impression is that the 'Write Room' is the best option of
these three options. At some point I may strip out Olivetti and Dark
Room if I don't find myself using them.

*** Low Distraction Writing Outside of Emacs.

The above is all about getting a low distraction writing environment
set up within Emacs. There is a strong argument that while this is a
good approach, as far as it goes, the reality is that the Emacs in
question is still running on a laptop with an internet connection (and
therefore the distractions that that provides), as well as games, both
casual and more intense.

On this basis, some time ago I began to become interested in the
existence of low distraction hardware. The first device I noticed was
the Pine64 laptop. This is a lightweight Arm based, minimal Linux
device, intended to run little more than a text terminal. It would be
fine for running an editor to write with no other options.

Then I saw adverts for the Freewrite Traveller device. This is a full
size mechanical keyboard with a clamshell lid which contains an e-ink
screen to display the text as you write it. The device has wifi
connectivity and the ability to write out your text to either Dropbox
or GoogleDrive. Unfortunately it also had what felt like a very hefty
price tag.

Searching for an alternative device, I discovered the Alphasmart
Neo2. This is a simple keyboard with an LCD screen to display the text
as you write it. It is a much simpler device which was originally
aimed as school classrooms which explains its robustness and the fact
that it was provided with some language learning tools. The biggest
advantage of these devices is that, thanks to their robustness, there
are still a lot around, and they can be picked up on eBay for a
reasonable sum. It is important to highlight that they are very
simplistic compared to the Freewrite, having to built-in wifi
function, and being designed mainly to transfer files to a 'proper'
computer by being connected to the computer using an USB cable at
which point the Alphasmart Neo2 becomes an external keyboard, typing
the text again into a suitably provided document on the computer. This
approach is fraught with many problems because of the temptation to
forget that the typing process is taking place, and move to a
different window, which will continue to receive the output that
should have been placed in the relevant text file. The other issue
that I had with my Neo2 is far more arcane and related to the fact
that I'm a Dvorak keyboard layout user. Neo2 can be switched to use a
Dvorak layout, which is extremely useful for me as I can touchtype
using Dvorak, but not Qwerty. The Dvorak in question isn't perfect for
my use as I usually use the UK Punctuation variation of Dvorak
provided on Linux (includes the £ sign), with a swapped Caps Lock and
left hand Ctrl key pair, but it is close enough. However, when using
the text transference method where the typing is repeated, the Dvorak
layout had another weird effect. The way that the external typing
worked was to send the key position for the character that it wanted
to send, not the character. So the a and m keys are the same on both
layouts, but everything else is different. I initially started working
around this by using the Linux 'tr' command which can be used to
process text using a 1-2-1 character mapping. However, I then
discovered that there is an open source project that provides a tool
for hoovering the text files from the Neo2 as text, and therefore the
Dvorak doesn't end up being an issue. This is done using a Python3
script 'neotools'. May add more details on this when I next use it.

Finally, I have backed a project on Kickstarter for a device called
Byok which is a small device that you connect your own keyboard to (it
stands for 'Bring Your Own Keyboard). This is a mix between the
Freewriter and the Alphasmart in that it has the wifi functionality
but the LCD screen. This should arrive some time before the end of the
year. I'll know how it deals with my Dvorak query when I receive it.

*** Focus Mode - Another Aspect of Low Distraction Editing.

An interesting take on the low distraction function is to dim text
that isn't being worked on.

#+begin_src emacs-lisp
  ;; Focus Mode
  (use-package focus
    :config (add-to-list 'focus-mode-to-thing '(text-mode . sentence))
    :config (add-to-list 'focus-mode-to-thing '(latex-mode . sentence))
    :config (add-to-list 'focus-mode-to-thing '(LaTeX-mode . sentence))
    :config (add-to-list 'focus-mode-to-thing '(org-mode . org-element))
    :config (add-to-list 'focus-mode-to-thing '(prog-mode . line))
    (add-hook 'text-mode-hook 'focus-mode)
    (add-hook 'latex-mode-hook 'focus-mode)
    (add-hook 'LaTeX-mode-hook 'focus-mode)
    (add-hook 'org-mode-hook 'focus-mode)
    (add-hook 'prog-mode-hook 'focus-mode)
    )
#+end_src

In Emacs, 'out of the box' the definition of a sentence requires two
spaces after the full stop. If only one space is used then it doesn't
work. I believe it is possible to use 'French Mode', but I will aim to
get back into the habit of using two spaces after the full stop.
** Writing Prose And Documents.
*** Groff/Troff Editing

To be added. I don't do much in the way of Groff editing anyway, but
the entry is there in preparation for stuff to be added.

*** HTML/CSS Editing Using Emmet

Nowadays the process of writing HTML is expected to result in a fully
balanced document tree. It is, of course, possible to write the whole
thing 'by hand', but there are usually tools for making it much
quicker and easier and to help guarantee the tags are properly
constructed.

The plugin Emmet is available on many platforms (I have it installed
in Visual Studio at work). This is the configuration for the Emacs
version.

#+begin_src emacs-lisp
  ;; Switch on emmet-mode
  (use-package emmet-mode)
  (require 'emmet-mode)
  (add-hook 'html-mode-hook 'emmet-mode)
  (add-hook 'css-mode-hook 'emmet-mode)
#+end_src

Using emmet mode involves typing a tag pattern and then type C-j to
expand the tags.

A cheatsheet shows how this works:

https://docs.emmet.io/cheat-sheet
*** LaTeX Using AucTeX/BibTeX/RefTeX.

When I first looked to install Linux in the late 1990s, the
installation process was much more basic than the one we know
today. There was a stage where a list of available packages was given,
and you could select or deselect the ones you wanted. As a beginner I
didn't know what was good, or practical. I did add Emacs (Vi was
preselected), and my journey was underway. To help me learn my way
around Emacs I bought the second edition of the Learning Emacs book by
O'Reilly. Working through the customisations recommended there, I read
about ways to write documents on Linux, given that there wasn't a good
word processor. I read about LaTeX, and soon was buying an
introductory book on using LaTeX.

So began a long time love affair with the weird world of writing
documents using an arcane markup language.

Fortunately Emacs has tools that make this process much easier. For
instance, the text expansion tools configured elsewhere.

Here the AucTeX tool is set up to help write LaTeX documents with the
minimum of fuss.

#+begin_src emacs-lisp
  ;; Install AucTeX for LaTeX editing.
  (use-package auctex
    :defer t
    :ensure t)
  ;; Add RefTeX for Reference and Link Management.
  (require 'reftex)
  (setq reftex-plug-into-AUCTeX t)
  ;; Switch on auto-saving for LaTeX documents.
  (setq TeX-auto-save t)
  ;; Switch on electric mode for AucTeX.
  (setq TeX-electric-escape t)
  ;; Make AucTeX parse documents for included documents and the like.
  (setq TeX-parse-self t)
  ;; Set the master document to nothing by default.
  (setq-default TeX-master nil)
  ;; Turn on RefTeX for both native LaTeX and latex modes.
  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
  (add-hook 'latex-mode-hook 'turn-on-reftex)
  ;; Activate Flyspell Mode
  (add-hook 'LaTeX-mode-hook 'flyspell-mode)
  (add-hook 'latex-mode-hook 'flyspell-mode)
  ;; Math Mode On
  (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
  (add-hook 'latex-math-mode 'LaTeX-math-mode)
  ;; Activate Outline Minor Mode.
  (add-hook 'LaTeX-mode-hook 'outline-minor-mode)
  (add-hook 'latex-mode-hook 'outline-minor-mode)
  ;; Folding enabled for macros and environments.
  (add-hook 'latex-mode-hook (lambda ()
  			     (TeX-fold-mode 1)))
  (add-hook 'LaTeX-mode-hook (lambda ()
  			     (TeX-fold-mode 1)))
  ;; Set me as the default author to load when \author{} is used
  (setq LaTeX-default-author '("Richard Fieldsend"))
#+end_src

This all worked as expected, but I will do a bit more testing and
probably create some sort of cheat sheet about the available functions
in my LaTeX configuration.
*** Manage the Bibliographic Databases Using eBib.

Having enabled LaTeX editing using AucTeX, the next step is to support
using the built-in reference management functionality 'BibTeX'. In
reality, I don't really have much need for this as I'm not writing
academic papers or the like, but it is a good way of managing the
books that I have and my 'to be read' list.

#+begin_src emacs-lisp
  ;; Activate and configure eBib for BibTeX database management.
  (use-package ebib
    :ensure ebib
    :config (global-set-key (kbd "C-c b") 'ebib)
    :config (setq ebib-bibtex-dialect 'biblatex)
    :config (setq ebib-file-bib-search-dirs '("~/bibliographies/"))
    :config (setq ebib-notes-directory '"~/bibliography-notes")
    :config (setq ebib-default-entry-type "Book")
    :config (setq ebib-preload-bib-files
  		'("~/bibliographies/humble.bib" "~/bibliographies/kindle.bib" "~/bibliographies/paperbacks.bib" "~/bibliographies/hardbacks.bib" "~/bibliographies/audiobooks.bib"))
    :config (setq ebib-keywords-field-keep-sorted t)
    :config (setq ebib-keywords "~/bibliographies/keywordslist.txt")
    :config (setq ebib-keywords-save-on-exit 'always)
    :config (setq ebib-reading-list-file "~/bibliographies/ToBeRead.org")
    :config (setq ebib-use-timestamp t)
    :config (setq ebib-autogenerate-keys t))
#+end_src

I will add some notes on using the eBib mode in the future.
*** Markdown and Org Mode Document Preparation.
**** Org Mode Code Tangling - Code Indentation.

One of the things that you can do in Org Mode is to embed sections of
code in a number of different languages. This file contains a number
of sections which use Emacs Lisp to configure my Emacs setup. I should
experiment a whole lot more into using this as a method of
experimenting with programming.

In the meantime the following configures the indentation for code
written in these code sections. This is most important in languages
that rely on indentation such as Python, but it also makes reading
code in other languages easier to read.

#+begin_src emacs-lisp
  ;; Indent programming code blocks appropriately.
  (setq org-src-tab-acts-natively t)
#+end_src

I'm leaving this code in place, but checking the variable description
shows that the value is already set to true.

**** Remember - The Emacs Remember Mode.

Remember mode is a way of gathering information and notes using Org
Mode. The notes will be saved in the folder ~/remember.

#+begin_src emacs-lisp
  ;; Configure the remember mode and related keystrokes.
  (require 'remember)
  (setq remember-data-directory "~/remember/")
  (setq remember-data-file "~/remember/notes.org")
  (define-key global-map (kbd "<f9> r") 'remember)
  (define-key global-map (kbd "<f9> R") 'remember-region)
#+end_src

** Programming Modes and Support.
*** Makefile.

There is a makefile-mode built-in in Emacs, so there is no necessity
for adding an extra setting at this time. However, this is where that
stuff would go if or when required.
*** Lisp/Clojure.


*** Python.

*** C/C++.

*** Rust.

*** Debugging.
* Footnotes

[fn:1] In Emacs, the term 'electric' behaviour refers to extra
behaviour triggered when various keys are pressed. The term is most
often used to describe the enter or return key moving the cursor to
the next line (the usual behaviour) and also carry out the action that
adding the tab key would provide. In writing code the electric
behaviour will indent the next line, especially useful when writing an
indent sensitive language such as Python.
